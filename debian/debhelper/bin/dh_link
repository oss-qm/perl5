#!/usr/bin/perl -w

=head1 NAME

dh_link - create symlinks in package build directories

=cut

use strict;
use Debian::Debhelper::Dh_Lib;

=head1 SYNOPSIS

B<dh_link> [S<I<debhelper options>>] [B<-A>] [S<I<source destination ...>>]

=head1 DESCRIPTION

dh_link is a debhelper program that creates symlinks in package build
directories.

dh_link accepts a list of pairs of source and destination files. The source
files are the already existing files that will be symlinked from. The
destination files are the symlinks that will be created. There B<must> be
an equal number of source and destination files specified.

The list can be specified in two ways. A file named debian/package.links
can list pairs of files. If you use this file, you should put each pair
of files on its own line, and separate the files within the pair with
whitespace. Also, pairs of files can be specified as parameters - these
pairs will only be created in the package build directory of the first
package dh_link is told to act on. By default, this is the first binary
package in debian/control, but if you use -p, -i, or -a flags, it will be
the first package specified by those flags.

Be sure you B<do> specify the full filename to both the source and
destination files (unlike you would do if you were using something like
L<ln(1)>).

dh_link will generate symlinks that comply with debian policy - absolute
when policy says they should be absolute, and relative links with as short
a path as possible. It will also create any subdirectories it needs to to put
the symlinks in.

=head1 OPTIONS

=over 4

=item B<-A>, B<--all>

Create any links specified by command line parameters in ALL packages
acted on, not just the first.

=item I<source destination ...>

Create a file named "destination" as a link to a file named "source". Do
this in the package build directory of the first package acted on.
(Or in all packages if -A is specified.)

=back

=head1 EXAMPLES

 dh_link usr/share/man/man1/foo.1 usr/share/man/man1/bar.1

Make bar.1 be a symlink to foo.1

 dh_link var/lib/foo usr/lib/foo \
   usr/X11R6/man/man1/foo.1x usr/share/man/man1/bar.1

Make /usr/lib/foo/ be a link to /var/lib/foo/, and bar.1 be a symlink to
the X man page foo.1x

=cut

init();

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmp=tmpdir($package);
	my $file=pkgfile($package,"links");

	my @links;
	if ($file) {
		@links=filearray($file);
	}

	# Make sure it has pairs of symlinks and destinations. If it
	# doesn't, $#links will be _odd_ (not even, -- it's zero-based).
	if (int($#links/2) eq $#links/2) {
		error("$file lists a link without a destination.");
	}

	if (($package eq $dh{FIRSTPACKAGE} || $dh{PARAMS_ALL}) && @ARGV) {
		push @links, @ARGV;
	}

	# Same test as above, including arguments this time.
	if (int($#links/2) eq $#links/2) {
		error("parameters list a link without a destination.");
	}

	while (@links) {
		my $dest=pop @links;
		my $src=pop @links;

		# Relavatize src and dest.
		$src=~s:^/::;
		$dest=~s:^/::;

		# Make sure the directory the link will be in exists.
		my $basedir=Debian::Debhelper::Dh_Lib::dirname("$tmp/$dest");
		if (! -e $basedir) {
			doit("install","-d",$basedir);
		}
		
		# Policy says that if the link is all within one toplevel
		# directory, it should be relative. If it's between
		# top level directories, leave it absolute.
		my @src_dirs=split(m:/+:,$src);
		my @dest_dirs=split(m:/+:,$dest);
		if ($src_dirs[0] eq $dest_dirs[0]) {
		    	# Figure out how much of a path $src and $dest
			# share in common.
			my $x;
			for ($x=0; $x<$#src_dirs && $src_dirs[$x] eq $dest_dirs[$x]; $x++) {}
			# Build up the new src.
			$src="";
			for (1..$#dest_dirs - $x) {
				$src.="../";
			}
			for ($x .. $#src_dirs) {
				$src.=$src_dirs[$_]."/";
			}
			$src=~s:/$::;
		}
		else {
			# Make sure it's properly absolute.
			$src="/$src";
		}
		
		doit("ln","-sf",$src,"$tmp/$dest");
	}
}

=head1 SEE ALSO

L<debhelper(1)>

This program is a part of debhelper.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

=cut

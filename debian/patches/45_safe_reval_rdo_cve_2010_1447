From: Rafael Garcia-Suarez <rgs@consttype.org>
Date: Thu, 29 Apr 2010 13:02:01 +0200
Subject: [PATCH] Wrap by default coderefs returned by rdo and reval

Origin: http://perl5.git.perl.org/perl.git/commit/554545435d592fa5ae8b79e031e59e9b09d6ff69
Bug-Debian: http://bugs.debian.org/631529

(suggested by Tim Bunce)

Modified to apply to 5.10 in Debian.

--- a/ext/Opcode/Safe.pm
+++ b/ext/Opcode/Safe.pm
@@ -346,6 +346,7 @@ sub reval {
                ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
                : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
     _clean_stash($root.'::') if $sg != sub_generation();
+    $obj->wrap_code_refs_within(@subret);
     return (wantarray) ? @subret : $subret[0];
 }
 
@@ -424,6 +425,7 @@ sub rdo {
                ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
                : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
     _clean_stash($root.'::') if $sg != sub_generation();
+    $obj->wrap_code_refs_within(@subret);
     return (wantarray) ? @subret : $subret[0];
 }
 
@@ -637,9 +639,9 @@ expression evaluated, or a return statement may be used, just as with
 subroutines and B<eval()>. The context (list or scalar) is determined
 by the caller as usual.
 
-This behaviour differs from the beta distribution of the Safe extension
-where earlier versions of perl made it hard to mimic the return
-behaviour of the eval() command and the context was always scalar.
+If the return value of reval() is (or contains) any code reference,
+those code references are wrapped to be themselves executed always
+in the compartment. See L</wrap_code_refs_within>.
 
 The formerly undocumented STRICT argument sets strictness: if true
 'use strict;' is used, otherwise it uses 'no strict;'. B<Note>: if

--- a/ext/Safe/t/safesort.t
+++ b/ext/Safe/t/safesort.t
@@ -33,13 +33,7 @@ EOS
 is $@, '', 'reval should not fail';
 is ref $func, 'CODE', 'reval should return a CODE ref';
 
-# $func1 will work in non-threaded perl
-# but RT#60374 "Safe.pm sort {} bug with -Dusethreads"
-# means the sorting won't work unless we wrap the code ref
-# such that it's executed with Safe 'in effect' at runtime
-my $func2 = $safe->wrap_code_ref($func1);
-
-my ($l_sorted, $p_sorted) = $func2->(3,1,2);
+my ($l_sorted, $p_sorted) = $func1->(3,1,2);
 is $l_sorted, "1,2,3";
 is $p_sorted, "1,2,3";

@@ -57,5 +51,6 @@ is $@, 42, 'successful closure call shou
     local $SIG{__WARN__} = sub { $warns++ };
     ok !eval { $die_func->("died\n"); 1 }, 'should die';
     is $@, "died\n", '$@ should be set correctly';
+    local $TODO = "Shouldn't warn";
     is $warns, 0;
 }

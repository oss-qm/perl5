#!/usr/local/bin/perl -w

use strict;
use IO::File;
use File::Temp;
use ExtUtils::Packlist;
use ExtUtils::Installed;

use vars qw($Inst @Modules);

################################################################################

sub do_module($)
{
my ($module) = @_;
my $help = <<EOF;
Available commands are:
   f [all|prog|doc]   - List installed files of a given type
   d [all|prog|doc]   - List the directories used by a module
   v                  - Validate the .packlist - check for missing files
   t <tarfile>        - Create a tar archive of the module
   q                  - Quit the module
EOF
print($help);
while (1)
   {
   print("$module cmd? ");
   my $reply = <STDIN>; chomp($reply);
   CASE:
      {
      $reply =~ /^f\s*/ and do
         {
         my $class = (split(' ', $reply))[1];
         $class = 'all' if (! $class);
         my @files;
         if (eval { @files = $Inst->files($module, $class); })
            {
            print("$class files in $module are:\n   ",
                  join("\n   ", @files), "\n");
            last CASE;
            }
         else
            { print($@); }
         };
      $reply =~ /^d\s*/ and do
         {
         my $class = (split(' ', $reply))[1];
         $class = 'all' if (! $class);
         my @dirs;
         if (eval { @dirs = $Inst->directories($module, $class); })
            {
            print("$class directories in $module are:\n   ",
                  join("\n   ", @dirs), "\n");
            last CASE;
            }
         else
            { print($@); }
         };
      $reply =~ /^t\s*/ and do
         {
         my $file = (split(' ', $reply))[1];
	 my ($fh, $tmp) = File::Temp::tempfile(UNLINK => 1);
	 $fh->print(join("\n", $Inst->files($module)));
	 $fh->close();
	 # This used to use -I which is wrong for GNU tar.
	 system("tar cvf $file -T $tmp");
	 unlink($tmp);
         last CASE;
         };
      $reply eq 'v' and do
         {
         if (my @missing = $Inst->validate($module))
            {
            print("Files missing from $module are:\n   ",
                  join("\n   ", @missing), "\n");
            }
         else
            {
            print("$module has no missing files\n");
            }
         last CASE;
         };
      $reply eq 'q' and do
         {
         return;
         };
      # Default
         print($help);
      }
   }
}

################################################################################

sub toplevel()
{
my $help = <<EOF;
Available commands are:
   l            - List all installed modules
   m <module>   - Select a module
   q            - Quit the program
EOF
print($help);
while (1)
   {
   print("cmd? ");
   my $reply = <STDIN>; chomp($reply);
   CASE:
      {
      $reply eq 'l' and do
         {
         print("Installed modules are:\n   ", join("\n   ", @Modules), "\n");
         last CASE;
         };
      $reply =~ /^m\s+/ and do
         {
         do_module((split(' ', $reply))[1]);
         last CASE;
         };
      $reply eq 'q' and do
         {
         exit(0);
         };
      # Default
         print($help);
      }
   }
}

################################################################################

$Inst = ExtUtils::Installed->new();
@Modules = $Inst->modules();
toplevel();

################################################################################

__END__

=head1 NAME

instmodsh - interactive inventory for installed Perl modules

=head1 SYNOPSIS

instmodsh

=head1 DESCRIPTION

C<instmodsh> provides an interactive shell to query details of
locally* installed Perl modules.

The shell provides a list of installed modules, each of which
may be queried to to list files and directories, checked for missing
files or packaged up as a tar archive.

*On Debian system, B<core> and B<vendor> modules are managed by C<dpkg>.

=head1 SEE ALSO

ExtUtils::Installed(3perl)

=cut
